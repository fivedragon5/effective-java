# ITEM01 : 생성자 대신 정적 메서드를 고려하라
### 장점
1. 이름을 가질 수 있다 (동일한 시그니처의 생성자를 두개 가질 수 없다.) 
 - 생성자의 인자값 갯수, 파라미터가 동일할 경우 컴파일 에러
 - 피할수 있는 방법은 있음
   - ex) 파라미터 수를 늘림, 위치를 변경함
2. 호출될 때마다 인스턴트를 새로 생성하지 않아도 된다.
 - new 클래스() 통제를 위해 생성자를 private으로 만듬
 - Boolean.valueOf()함수
   - 넘어오는 인자에 따라 미리 만들어둔 instance를 return해줌
 - 플라이 웨이트 패턴
   - 자주 사용하는 인스턴스또는 값들을 미리 만들어두고 꺼내서 쓰는 패턴 ex)폰트
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.(인터페이스 기반 프레임워크, 인터페이스에 정적 메소드)
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. (EnumSet)
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. (서비스 제공자 프레임워크)
 - import me.whiteship.hello.ChineseHelloService;을 하지않아도 됌

### 단점
1. 상속을 하려면 public이나 protected생성하기 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
 - 상속대신 Settings settings;으로 재정의 해서 사용 가능
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
 - javadoc 문서화에서 생성자는 한눈에 들어오지만 method는 많아지면 많아질 수록 찾기 힘듬
 - mvn javadoc:javadoc 위치 : target/site/index.html에 생성됌

완벽공략
1. 열거타입
 - Enumeration
   - enum.valus()
   - 자바의 클래스처럼 생성자 메소드 필드 가질 수 있음
   - == or equals중 무엇을 사용?? NullpointException

2. 플라이 웨이트 패턴
 - 같은 객체가 자주 사용되는 경우

3. 인터페이스가 정적 메서드를 가질 수 있음
 - 
4. 서비스 제공자 프레임워크
5. 서비스 제공자 인터페이스 리플렉션
   